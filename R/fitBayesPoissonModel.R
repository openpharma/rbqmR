#' Fit an MCMC Poisson Model to Site-specific Event Rates
#'
#' Given a set of event data for multiple sites, fit a Bayesian hierarchical
#' Poisson model to the site-specific event rates.
#'
#' Adverse events at a given site are assumed to follow a Poisson
#' distribution, a standard statistical distribution that expresses the
#' probability of a given number of events in a fixed time interval.
#' The probability depends on a site-specific rate parameter
#' \eqn{\lambda_i}{lambda_i} multiplied by the exposure (total time on
#' treatment for all patients at that site).

#' The site-specific event rates, \eqn{\lambda_i}{lambda_i},
#' are assumed to follow a Gamma distribution; a positive continuous
#' distribution with two parameters, shape and scale, that determine the
#' average rate and how spread the probability of different rates is
#' around that average.

#' Uncertainty in the shape and scale of this distribution is accounted for by
#' specifying prior distributions on these parameters. These "hyper-priors" are
#' also specified as Gamma distributions.
#'
#' The parameters of the hyper-priors are specified by `shape` and `scale`.
#' The default settings specify Gamma(1, 1) distributions which are equivalent
#' to Exp(1) distributions.
#'
#' The Bayesian Hierarchical Model then estimates the posterior distribution
#' for the unknown parameters \eqn{\lambda_i}{lambda_i}, scale and shape,
#' given the observed events. Under Bayes Theorem this is proportional to the
#' likelihood of the observed data given the parameters multiplied by the prior
#' for the parameters. The prior can be informed by historical data and/or
#' expert knowledge. As more data are available, the posterior is less
#' influenced by the prior and more influenced by the data.
#'
#' The exact posterior distribution cannot be computed directly, hence a Markov
#' Chain Monte Carlo (MCMC) method is used to simulate values of
#' \eqn{\lambda_i}{lambda_i}, scale and shape from the posterior distribution.
#' Two Markov chains are used, with a minimum of 10,000 values simulated after
#' 4000 burn-in iterations and 1000 adaptive iterations. The chains are checked
#' for convergence and the simulation is extended if required to meet
#' convergence diagnositics. The samples from both chains are combined in the
#' returned value.
#'
#' @param data the data frame containing the `eventVar` and `exposureVar` columns
#' @param events The number of events per site. If `NULL` the "posterior"
#' distribution will be MCMC samples from the prior.
#' @param exposure The exposure per site. If `NULL` the "posterior"
#' distribution will be MCMC samples from the prior.
#' @param model The character string containing the JAGS model to be fitted.  If
#' `NULL`, obtained from `getModelString("binomial)`.
#' @param inits A list of JAGS inits lists suitable for use with this model.  If
#' `NULL` (the default), `nChains` random inits are generated by 
#' [`.createPoissonInit`].
#' @param nChains The number of chains to use.  Default 2.  If `inits` is not 
#' `NULL`, must equal `length(inits)` or be `NULL`.
#' @param ... passed to `.createPoissonInit` or `.autorunJagsAndCaptureOutput`
#'
#' @return A tibble with four columns
#' \item{lambda}{Simulated values from the posterior distribution of the rates.}
#' \item{shape}{Simulated values from the posterior distribution of the shape.}
#' \item{scale}{Simulated values from the posterior distribution of the scale.}
#' \item{q}{Percentile in each which lambda value falls.}
#' @examples
#'
#' # load example site rates
#' data(siteRates)
#'
#' # fit MCMC Poisson model with default hyperpriors (basis 1 month)
#' results <- siteRates %>% fitBayesPoissonModel(Events, Exposure)
#'
#' @export
fitBayesPoissonModel <- function(
                          data, # allow NULL to simulate prior of lambda
                          events = NULL, 
                          exposure = NULL,
                          model=NULL,
                          inits=NULL,
                          nChains=ifelse(is.null(inits), 2, length(inits)),
                          ...
                        ){
  logger::log_debug("Entry")
  logger::log_trace(deparse(match.call()))
  # Validate
  if (!is.null(data)) {
    if (any(is.na(data %>% dplyr::pull({{events}})))) {
      stop(paste0("Some entries in ", substitute(events), " are NA"))
    }
    if  (any(is.na(data %>% dplyr::pull({{exposure}})))) {
      stop(paste0("Some entries in ", substitute(exposure), " are NA"))
    }
    if (!(min(data %>% dplyr::pull({{events}})) >= 0)) {
      stop(paste0("Not all entries in ", substitute(events), " are non-negative"))
    }
    if (!(min(data %>% dplyr::pull({{exposure}})) >= 0)) {
      stop(paste0("Not all entries in ", substitute(exposure), " are non-negative"))
    }
  }
  #Begin
  #Add additional, "posterior" observation to each input vector
  tempData <- list()
  if (!is.null(data)) {
    tempData$events <- c(data %>% dplyr::pull({{events}}), NA)
    tempData$exposure <- c(data %>% dplyr::pull({{exposure}}),  1)
  }
  tempData$k <- length(tempData$events) # number of sites plus 1
  
  if(is.null(model)) {
    model <- getModelString("poisson", prior=is.null(data))
    logger::log_trace(
      paste0(
        "  Model is now:\n", 
        # Needed to allow logger to work: escape curly braces, which are control
        # characters in glue
        stringr::str_replace_all(model, c("\\{"="\\{\\{", "\\}"="\\}\\}"))
      )
    )
  }
  
  # Create init lists if required
  if (is.null(inits)) {
    logger::log_debug("Generating random inits")
    inits <- lapply(1:nChains, function(x) .createPoissonInit(n=tempData$k))
  }
  
  # set runjags options
  ## always force summary, others set in zzz.R could be changed by user
  runjags::runjags.options(force.summary = TRUE)
  # runjags.options(silent.jags = FALSE)
  # use autorun jags to ensure convergence diagnostics are met
  if (is.null(data)) {
    toMonitor <- c("shape", "scale")
  } else {
    toMonitor <- c(paste0("lambda[", tempData$k , "]"), "shape", "scale")
  }
  print(inits)
  tempData %>%
    .autorunJagsAndCaptureOutput(
      model,
      toMonitor,
      inits,
      "poissonModel"
    )
}
