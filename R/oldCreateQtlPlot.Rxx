#' Summary Plot of Observed Event Rates/Proportions
#'
#' Create a summary plot of observed event rates or proportions, optionally
#' plotting alongside the density of a fixed distribution or the density of a
#' posterior distribution, with highlighting of quantiles and marking
#' of thresholds across facets.
#'
#' The base plot shows a bar at each event rate/proportion, with the height of
#' the bar representing the exposure/number of patients. The bars may be
#' coloured by site type, if `showSiteType = TRUE` and `siteData`
#' contains a variable named `Type`.
#'
#' If either `fixedData` or `mcmcData` is specified, the plot is split into
#' two facets, with the bottom plot as described above and the top plot showing
#' the density given in `fixedData` and/or the density given in `mcmcData`.
#'
#' If `mcmcData` is specified and both `showSiteType = FALSE` and
#' `showRanges = TRUE`, the facets are coloured to highlight top and bottom
#' quantile ranges, with borders specified by `limits`. The colour and
#' transparency of each range is specified by `rangeAlpha` and `rangeColours`
#' respectively. These values are reversed when applied to the top ranges so
#' e.g. the colour applied between the 1st and 5th percentiles is the same as
#' that applied between the 95th and 99th percentiles. If
#' `showThresholds = TRUE`, dashed lines in the same colours indicate the
#' range limits. Note the upper quantiles may not be displayed, depending on
#' `xmax`.
#'
#' If `xref1`, `xref2` and `trendAlert` provide options to add vertical lines
#' at reference values on the x-axis, either specified by value (`xref1`,
#' `xref2`) or quantiles of the fitted parameter distribution given in
#' `mcmcData`. The colours can be modified via `xref1Colour`, `xref2Colour` and
#' `trendAlertColour` respectively.
#'
#' @param siteData A data frame containing the event data summarized by site,
#' as returned by [summarize_by_site()].
#' @param basis The basis of the rate in number of months. Will use attibute
#' of the same name from `siteData` if available, or 1 month by default.
#' @param fixedData Optional. A data frame with a columns named `x` and `y`
#' specifying a fixed density to plot.
#' @param mcmcData Optional. The results of a call to [fitMcmcPoissonModel()],
#' [fitMcmcZipModel()] or [fitMcmcBinomialModel()]. If provided,
#' a density plot of the posterior rates/probabilities is added.
#' @param mcmcAlpha A value between 0 and 1 specifying the alpha
#' transparency of the MCMC density.
#' @param mcmcColour The outline colour of the MCMC density.
#' @param showRanges Logical: if `TRUE` and if `mcmcData` is not `NULL`, show
#' coloured top and bottom percentile ranges with limits specified by `limits`.
#' @param showThresholds Logical: if `TRUE` and `showRanges` is `TRUE`, show
#' the thresholds of the percentile ranges on the bottom facet.
#' @param rangeAlpha Value between 0 and 1 giving alpha transparency of
#' coloured quantile ranges.
#' @param rangeColours Colours for the quantile ranges, with length equal to
#' `limit` (colours are reversed for upper ranges).
#' @param medianColour Colour for median reference line, also used for
#' observed data not in the highlighted percentile ranges.
#' @param xLabel A label for the x-axis.
#' @param yLabel A label for the y-axis.
#' @param limits A vector specifying the upper limit of the bottom quantile
#' ranges, subtracted from 1 to give the lower limit of the top quantile
#' ranges (e.g. 0.01 specifies limits at the top and bottom 1%).
#' @param xref1 A vector of values at which to add vertical dashed reference
#' lines in `xref1Colour`.
#' @param xref2 A vector of values at which to add vertical dashed reference
#' lines in `xref2Colour`.
#' @param trendAlert A vector of quantiles to derive from `mcmcData` and to
#' represent with vertical solid lines in `trendAlertColour`.
#' @param xref1Colour A colour to use for reference lines specified by `xref1`.
#' @param xref2Colour A colour to use for reference lines specified by `xref2`.
#' @param trendAlertColour A colour to use for the trend alert quantile lines
#' specified by `trendAlert`.
#' @param xref1Lab A label to use for reference lines specified by `xref1`.
#' @param xref2Lab A label to use for reference lines specified by `xref2`.
#' @param trendAlertLab A label to use for the trend alert quantile lines
#' specified by `trendAlert`.
#' @param xmax The maximum event rate to plot. If not specified, the maximum
#' out of the maximum `xref` and the minimum out of the maximum observed rate
#' and the maximum quantile specified by `limit`, in any case, rounded up to
#' the next integer.
#' @param nDensity The number of equally spaced points at which the density
#' is to be estimated, when colouring the density within each range. This must
#' be a power of 2 and may need to be increased to avoid white gaps in the
#' shading.
#' @return A `"ggplot"` object is returned except when quantile ranges are
#' shown - in this case, in order to draw thresholds across the plots, the plot
#' is drawn directly in the plotting device and the return value is `NULL`.
#' @note The default colours are from Peter Kovesi's linear green palette as
#' implemented in <code>kovesi.linear_green_5_95_c69()</code> from the
#' [https://github.com/kwstat/pals](pals) package. From a palette of six
#' colours, the first four are used for `rangeColours` and the fifth is used
#' for `medianColour`.
#'
#' @examples
#'
#' # load example site summary data
#' data(siteRates)
#'
#' # plot observed rates only
#' createQtlPlot(siteData = siteRates)
#'
#' # plot observed rates with fixed density
#' createQtlPlot(siteData = siteRates,
#'               fixedData = density(rgamma(1000, 1, 1))[c("x", "y")])
#'
#' # fit MCMC Poisson model with default hyperpriors
#' results <- fitMcmcPoissonModel(siteRates$n_events,
#'                                siteRates$exposure_months)
#'
#' # plot fitted posterior distribution for rate alongside observed rates
#' createQtlPlot(siteData = siteRates,
#'               mcmcData = results$tab,
#'               xmax = 16,
#'               xref1 = c(0.5, 7),
#'               xref2 = c(1, 4))
#' @export
createQtlPlot <- function(siteData,
                          basis = attr(siteData, "basis"),
                          fixedData = NULL,
                          mcmcData = NULL,
                          mcmcAlpha = 0.5,
                          mcmcColour = "grey",
                          showRanges = TRUE,
                          showThresholds = TRUE,
                          rangeAlpha = 0.3,
                          rangeColours = c("#011506", "#0B3F05",
                                           "#187008", "#25A30E"),
                          medianColour = "#33DA14",
                          xLabel = NULL,
                          yLabel = NULL,
                          limits = c(0.01, 0.05, 0.1, 0.2),
                          xref1 = NULL,
                          xref2 = NULL,
                          trendAlert = NULL,
                          xref1Colour = "royalblue1",
                          xref2Colour = "tan1",
                          trendAlertColour = "purple1",
                          xref1Lab = "xref1",
                          xref2Lab = "xref2",
                          trendAlertLab = "trendAlert",
                          xmax = NULL,
                          nDensity = 2^14,
                          statistic= ifelse("proportion" %in% names(siteData), "proportion", "rate"))
{
  if (statistic == "rate"){
    if (is.null(basis)) basis <- 1
    names(siteData)[ncol(siteData)] <- "rate"
    siteData$exposure <- siteData$exposure_months/basis
  }

  parameter <- ifelse(statistic == "rate", "lambda", "p")
  size <- ifelse(statistic == "rate", "exposure", "n_patients")
  if (is.null(xLabel)) xLabel <- ifelse(statistic == "rate",
                                        "Observed rate",
                                        "Observed proportion")
  if (is.null(yLabel)) {
    yLabel <- ifelse(statistic == "rate",
                     paste0("Exposure (",
                            switch(as.character(basis),
                                   "1" = "months",
                                   "12" = "years",
                                   paste(basis, "mths")), ")"),
                     "No. patients")
  }

  if (!isTRUE(is.finite(xmax))){
    if (statistic == "rate"){
      max <- max(siteData$rate)
      if (!is.null(mcmcData) && showRanges){
        # show all quantiles and reference lines
        xmax <- ceiling(max(quantile(mcmcData$lambda, max(1 - limits)),
                            if (!is.null(trendAlert))
                              quantile(mcmcData$lambda, trendAlert),
                            xref1, xref2))
        # show maximum x value if less than 1 unit higher
        diff <- max - xmax
        if (diff >= 0 & diff <= 1) xmax <- xmax + 1
      } else {
        # show 90th quantile
        xmax <- ceiling(quantile(siteData$rate, 0.9))
        # show maximum x value if less than 1 unit higher
        diff <- max - xmax
        if (diff >= 0 & diff <= 1) xmax <- xmax + 1
      }
    } else xmax <- 1
  }
  # Combine all data to plot
  plotData <- dplyr::bind_rows(siteData = siteData, fixedData = fixedData,
                        mcmcData = mcmcData, .id = "Set")
  plotData$Facet <- ifelse(plotData$Set == "siteData", "Exposure", "Density")

  # Plot observed data
  plot <- ggplot2::ggplot()
  # Plot fixed density if provided
  if (!is.null(fixedData)) {
    plot <- plot +
      ggplot2::geom_line(data = plotData[plotData$Set == "fixedData",],
                ggplot2::aes_string(x = "x", y = "y"), linetype = "dotted")
  }
  # Plot density from MCMC if provided
  if (!is.null(mcmcData))
  {
    #JK 29Jun2018
    #plot <- plot + geom_density(data=mcmcData, ggplot2::aes(lambda, alpha=mcmcAlpha), colour=mcmcColour, inherit.aes=FALSE)
    plot <- plot +
      ggplot2::geom_density(data = plotData[plotData$Set == "mcmcData",],
                   ggplot2::aes_string(x = parameter), alpha = mcmcAlpha,
                   colour = mcmcColour, inherit.aes = FALSE, n = nDensity)
    if (!is.null(medianColour)){
      medianValue <- obtainQtl(0.5, mcmcData, parameter)
    }
    if (showRanges)
    {
      limits <- sort(limits)
      quantiles <- c(limits, rev(1 - limits))
      quantiles <- vapply(quantiles, obtainQtl, numeric(1),
                          mcmcData, parameter)

      if (is.null(fixedData)) idx <- 1
      else idx <- 2
      plot <-
        shadeActionAndWarningRanges(plot, quantiles,
                                    rangeAlpha, rangeColours, idx)
    }
  }
  # Add reference lines if provided
  refLines <- refLineTypes <- numeric()
  refLineColours <- character()
  if (!is.null(xref1)){
    plot <- plot +
      ggpplot2::geom_vline(aes_string(xintercept = "xintercept", alpha = "alpha"),
                 tibble::tibble(xintercept = xref1,
                        alpha = rep(xref1Lab, length(xref1))),
                 colour = xref1Colour, linetype = 1, size = ggplot2::rel(0.8),
                 show.legend = TRUE)
    tmp <- 0.9999
    names(tmp) <- xref1Lab
    refLines <- c(refLines, tmp)
    refLineColours <- c(refLineColours, xref1Colour)
    refLineTypes <- c(refLineTypes, 1)#5

  }
  if (!is.null(xref2)){
    plot <- plot +
      ggplot2::geom_vline(ggplot2::aes_string(xintercept = "xintercept", alpha = "alpha"),
                 tibble::tibble(xintercept = xref2,
                        alpha = rep(xref2Lab, length(xref2))),
                 colour = xref2Colour, linetype = 1, size = ggplot2::rel(0.8),
                 show.legend = TRUE)
    tmp <- 0.9998
    names(tmp) <- xref2Lab
    refLines <- c(refLines, tmp)
    refLineColours <- c(refLineColours, xref2Colour)
    refLineTypes <- c(refLineTypes, 1)#5

  }
  if (!is.null(mcmcData) && showRanges) {
    plotData$alert <- cut(plotData[[statistic]],
                          c(-Inf, quantiles, Inf))
    col <- c(rangeColours,
             ifelse(!is.null(medianColour), medianColour, "grey"),
             rev(rangeColours))
    names(col) <- levels(plotData$alert)
    plot <- plot +
      geom_custom_point(data = plotData[plotData$Set == "siteData",],
                        ggplot2::aes_string(x = statistic, y = size,
                                   colour = "alert"),
                        shape = 180, alpha = 0.5, size = ggplot2::rel(4)) +
      ggplot2::geom_linerange(data = plotData[plotData$Set == "siteData",],
                     ggplot2::aes_string(x = statistic, ymin = 0, ymax = size,
                                colour = "alert"), alpha = 0.5) +
      scale_colour_manual(values = col)
  } else {
    plot <- plot +
      geom_custom_point(data = plotData[plotData$Set == "siteData",],
                        ggplot2::aes_string(x = statistic, y = size),
                        shape = 180, alpha = 0.5, size = ggplot2::rel(4)) +
      ggplot2::geom_linerange(data = plotData[plotData$Set == "siteData",],
                     ggplot2::aes_string(x = statistic, ymin = 0, ymax = size),
                     alpha = 0.5)
  }

  ## add range thresholds
  if (!is.null(mcmcData))
  {
    if (showThresholds)
    {
      threshold_col <- names(col)[-(length(limits) + 1)]
      ### exclude if beyond range of x (always start at zero, so min ok)
      exc <- quantiles > xmax*1.05
      plot <- plot +
        ggplot2::geom_vline(data = tibble::tibble(x = quantiles,
                                 Facet = "Exposure",
                                 col = threshold_col)[!exc,],
                   ggplot2::aes_string(xintercept = "x", colour = "col"),
                   linetype = 3, size = ggplot2::rel(0.7), alpha = min(rangeAlpha*3, 1))
    }
    if (!is.null(medianColour)){
      plot <- plot +
        ggplot2::geom_vline(data = tibble::tibble(xintercept = medianValue,
                                 alpha = "Median"),
                   ggplot2::aes_string(xintercept = "xintercept", alpha = "alpha"),
                   linetype = 2, size = ggplot2::rel(1), alpha = 1,
                   colour = medianColour)
      tmp <- 0.9997
      names(tmp) <- "Median"
      refLines <- c(refLines, tmp)
      refLineColours <- c(refLineColours, medianColour)
      refLineTypes <- c(refLineTypes, 2)
    }

    if (!is.null(trendAlert)){
      trendAlert <- vapply(trendAlert, obtainQtl, numeric(1),
                           mcmcData, parameter)
      plot <- plot +
        ggplot2::geom_vline(ggplot2::aes_string(xintercept = "xintercept", alpha = "alpha"),
                   tibble::tibble(xintercept = trendAlert,
                          Facet = "Exposure",
                          alpha = rep(trendAlertLab, length(trendAlert))),
                   colour = trendAlertColour, linetype = 5, size = ggplot2::rel(0.8),
                   show.legend = TRUE)
      tmp <- 0.9996
      names(tmp) <- trendAlertLab
      refLines <- c(refLines, tmp)
      refLineColours <- c(refLineColours, trendAlertColour)
      refLineTypes <- c(refLineTypes, 5)#1
    }
  }

  if (!is.null(xref1) || !is.null(xref1) || !is.null(trendAlert)){
    plot <- plot +
      scale_alpha_manual(name = NULL,
                         limits = names(refLines),
                         values = refLines,
                         guide =
                           guide_legend(
                             keyheight = 2,
                             override.aes = list(
                               colour = refLineColours,
                               linetype = refLineTypes))) +
      ggplot2::theme(legend.key = ggplot2::element_rect(fill = "white"))
  }

  # Theme plot
  plot <- plot +
    ggplot2::xlab(xLabel) +
    ggplot2::coord_cartesian(xlim = c(0, xmax)) +
    ggplot2::theme(panel.background = ggplot2::element_rect(fill = "white", colour = NA),
          panel.border = ggplot2::element_rect(fill = NA,
                                      colour = "grey70", size = ggplot2::rel(1)),
          panel.grid.major = ggplot2::element_line(linetype = 3, colour = "grey77",
                                          size =ggplot2::rel(1)),
          panel.grid.major.x = ggplot2::element_blank())
  # Separate density plot(s)
  if (!is.null(fixedData) ||!is.null(mcmcData)){
    plot <- plot +
      ggplot2::facet_wrap(~ Facet, nrow = 2, scales = "free_y",
                 strip.position = "left",
                 labeller = as_labeller(c(Exposure = yLabel,
                                          Density = "Density")))  +
      ggplot2::ylab(NULL) +
      ggplot2::theme(strip.background = ggplot2::element_blank(),
            strip.placement = "outside") +
      guides(colour = FALSE)
  } else plot <- plot + ggplot2::ylab(yLabel)
  return(plot)
}

#' @importFrom dplyr filter summarise
obtainQtl <- function(qtl, mcmcData, parameter)
{
  if (qtl < 0 || qtl > 1)  rv <- qtl
  else rv <- unlist(mcmcData %>%
                      filter(.data$q == round(qtl * max(.data$q))) %>%
                      summarise(value = max(.data[[parameter]])))
  return (rv)
}

# Warning and action limits can be modified here
#' @import ggplot2
shadeActionAndWarningRanges <- function(plot,
                                        limits = c(0.1, 0.2, 0.8, 0.9),
                                        rangeAlpha=0.3,
                                        rangeColours=c(c("#011506", "#0B3F05",
                                                         "#187008", "#25A30E")),
                                        idx=2)
{
  #Validate
  if (is.null(plot)) stop("Plot cannot be null")

  d <- ggplot_build(plot)$data[[idx]] #2 (or 3) because the MCMC density is the second (or third) component of the ggplot created by createXXXXQtlPlot()
  d$Facet <- "Density" # so only adds to density facet

  # extend limits and colours
  limits <- c(-Inf, limits, Inf)
  n <- length(limits)
  rangeColours <- c(rangeColours, NA, rev(rangeColours))
  for (i in seq(n - 1)){
    if (is.na(rangeColours[i])) next
    inRange <- with(d, x >= limits[i] & x <= limits[i + 1])
    ok <- any(inRange)
    if (ok) {
      plot <- plot +
        ggplot2::geom_area(data = d[inRange,],
                  ggplot2::aes_string(x = "x", y = "y"), alpha = rangeAlpha,
                  fill = rangeColours[i], inherit.aes = FALSE)
    } else {
      warning("The MCMC density has no fitted points between ", limits[i],
              " and ", limits[i + 1],
              ". Increase nDensity, ensuring it remains a power of two")
    }
  }
  return (plot)
}

# custom geom to use symbol font (font = 5)
#' @importFrom grid gpar pointsGrob
GeomCustomPoint <- ggplot2::ggproto("GeomCustomPoint", ggplot2::Geom,
                           required_aes = c("x", "y"),
                           default_aes = ggplot2::aes(
                             shape = 19, colour = "black", size = 1.5, fill = NA,
                             alpha = NA, stroke = 0.5
                           ),
                           draw_key = ggplot2::draw_key_point,

                           draw_panel = function(data, panel_params, coord) {
                             coords <- coord$transform(data, panel_params)
                             grid::pointsGrob(
                               coords$x, coords$y,
                               pch = coords$shape,
                               gp = grid::gpar(
                                 col = alpha(coords$colour, coords$alpha),
                                 fill = alpha(coords$fill, coords$alpha),
                                 # Stroke is added around the outside of the point
                                 fontsize = coords$size * .pt +
                                   coords$stroke * .stroke / 2,
                                 lwd = coords$stroke * .stroke / 2,
                                 font = 5)
                             )
                           }
)

geom_custom_point <- function(mapping = NULL, data = NULL, stat = "identity",
                              position = "identity", na.rm = FALSE, show.legend = NA,
                              inherit.aes = TRUE, ...) {
  ggplot2::layer(
    geom = GeomCustomPoint, mapping = mapping,  data = data, stat = stat,
    position = position, show.legend = show.legend, inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}
