#' Fit an MCMC Binomial Model to site-specific Counts
#'
#' Given a set of event counts and patient numbers for multiple sites,
#' where the event can occur at most once per patient, fit a Bayesian
#' hierarchical Binomial model to the site-specific event counts.
#'
#' The count of patients experiencing an event at a given site is
#' assumed to follow a Binomial distribution, a standard statistical
#' distribution that expresses the probability of a given number of
#' events out of a fixed number of possible events. The probability
#' depends on a site-specific probability for the event to occur for a
#' single patient `p_i` and the total number of patients at
#' each site.

#' The site-specific probabilities, `p_i`,
#' are assumed to follow a Beta distribution; a continuous
#' distribution of values between 0 and 1, with two parameters, `a`
#' and `b`, that determine the shape and skewness of the
#' distribution.

#' Uncertainty in the parameters of the Beta distribution is accounted
#' for by specifying prior distributions on these parameters. These
#' "hyperpriors" are specified as Gamma distributions.
#'
#' The parameters of the hyper-priors are specified by `a` and `b`.
#' The default settings specify Gamma(1, 10) distributions which allow
#' bell-shaped distributions for `0.05 < p_i < 0.95`, but put a low
#' probability of very precise distributions.
#'
#' The Bayesian Hierarchical Model then estimates the posterior distribution
#' for the unknown parameters `p_i`, `a` and `b`,
#' given the observed events. Under Bayes Theorem this is proportional to the
#' likelihood of the observed data given the parameters multiplied by the prior
#' for the parameters. The prior can be informed by historical data and/or
#' expert knowledge. As more data are available, the posterior is less
#' influenced by the prior and more influenced by the data.
#'
#' The exact posterior distribution cannot be computed directly, hence a Markov
#' Chain Monte Carlo (MCMC) method is used to simulate values of
#' `p_i`, `a` and `b` from the posterior distribution.
#' Any number Markov chains can be used, each with a minimum of 10,000 values
#' simulated after 4000 burn-in iterations and 1000 adaptive iterations.
#' The chains are checked for convergence and the simulation is extended if
#' required to satisfy basic convergence tests. The samples from all chains are
#' combined in the returned value.
#'
#' @param data  The data.frame containing the participant and event counts
#' @param n The column in `data` containing the participant counts.  Uses
#' tidy evaluation
#' @param r The column in `data` containing the event counts.  Uses tidy 
#' evaluation
#' @param model The character string containing the JAGS model to be fitted.  If
#' `NULL`, obtained from `getModelString("binomial)`.
#' @param inits A list of JAGS inits lists suitable for use with this model.  If
#' `NULL` (the default), `nChains` random inits are generated by 
#' [`.createBinomialInit`].
#' @param nChains The number of chains to use.  Default 2.  If `inits` is not 
#' `NULL`, must equal `length(inits)` or be `NULL`.
#' @param ... passed to .createBinomialInits or .autorunJagsAndCaptureOutput
#' @return A tibble with four columns
#' \item{p}{Simulated values from the posterior distribution of the event
#' probabilities.}
#' \item{shape1}{Simulated values from the posterior distribution of the first
#' shape parameter of the Beta distribution for `p`.}
#' \item{shape2}{Simulated values from the posterior distribution of the second
#' shape parameter of the Beta distribution for `p`.}
#' \item{q}{Percentile in which each p value falls.}
#' @example examples/fitBayesBinomialModel.R
#' @export
fitBayesBinomialModel <- function(
                           data,
                           n,
                           r,
                           model=NULL,
                           inits=NULL,
                           nChains=ifelse(is.null(inits), 2, length(inits)),
                           ...
                         ) {
  futile.logger::flog.debug("Entry")
  futile.logger::flog.trace(deparse(match.call()))
  #Validate
  if (!is.null(data)) {
    n_ <- data %>% dplyr::pull({{ n }})
    r_ <- data %>% dplyr::pull({{ r }})
    if (any(is.na(n_))) {
      stop(paste0("Some entries in ", substitute(n), " are NA"))
    }
    if  (any(is.na(r_))) {
      stop(paste0("Some entries in ", substitute(r), " are NA"))
    }
    if (!(min(n_) > 0)) {
      stop(paste0("Not all entries in ", substitute(n), " are positive"))
    }
    if (!(min(r_) >= 0)) {
      stop(paste0("Not all entries in ", substitute(r), " are non-negative"))
    }
    if (any(floor(n_) != n_)) {
      stop(paste0("Not all entries in ", substitute(n), " are integers"))
    }
    if (any(floor(r_) != r_)) {
      stop(paste0("Not all entries in ", substitute(r), " are integers"))
    }
    if (any(r_ > n_)) {
      stop(
        paste0(
          "Not all entries in ", 
          substitute(r), 
          " are less than or equal to the corresponding entry in ", 
          substitute(n)
        )
      )
    }
    if (!is.null(inits)) {
      for (i in 1:length(inits)) {
        if (length(setdiff(names(inits[[i]]), c("p", "a", "b", ".RNG.name", ".RNG.seed"))) != 0) {
          stop(paste0("The names of the ", i, "th element of inits are not valid"))
        }
      }
    }
  }
  #Begin
  #Add additional, "posterior", observation to each input vector
  tempData <- list()
  if (!is.null(data)) {
    tempData$r <- c(data %>% dplyr::pull({{r}}), NA)
    tempData$n <- c(data %>% dplyr::pull({{n}}),  1)
    tempData$k <- length(tempData$r) # number of sites plus 1
  } else {
    tempData$k <- 1
  }
  
  # JAGS description of the model to be fitted.
  if (is.null(model)) {
    model <- getModelString("binomial", prior=is.null(data))
    futile.logger::flog.trace(
      paste0(
        "  Model is now:\n", 
        # Needed to allow logger to work: escape curly braces, which are control
        # characters in glue
        stringr::str_replace_all(model, c("\\{"="\\{\\{", "\\}"="\\}\\}"))
      )
    )
  }
  # Create init lists if required
  if (is.null(inits)) {
    futile.logger::flog.debug("Generating random inits")
    inits <- lapply(1:nChains, function(x) .createBinomialInit(n=tempData$k))
  }
  if (is.null(data)) {
    toMonitor <- c("a", "b")
  } else {
    toMonitor <- c(paste0("p[", tempData$k , "]"), "a", "b")
  }
  # Fit the model
  rv <- tempData %>%
          .autorunJagsAndCaptureOutput(
            model,
            toMonitor,
            inits,
            ...
        )
  futile.logger::flog.debug("Exit")
  return(rv)
}